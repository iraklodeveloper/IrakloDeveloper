//დავალება ნ1⬇

/* function factorialRecursive(n) {
    console.log(n);
    if (n === 0 || n === 1) {
        return 1;
    }
    // წესი: „ბოლო შემოვიდა, პირველი გავა“ (LIFO - Last In, First Out) ⬇
        // 2 * 1 = 2 ⬇
        // 3 * 2 = 6 ⬇
        // 4 * 6 = 24 ⬇
        // 5 * 24 = 120 ✔
    // if პირობამ დააბრუნა factorialRecursive(n - 1)-ის საბოლოო მნიშვნელობა: 1. 
    // 2 * ? ⬆ factorialRecursive(n - 1) გახდა 1
    // 3 * ? ⬆
    // 4 * ? ⬆
    // 5 * ? ⬆
    return n * factorialRecursive(n - 1);
}
console.log(factorialRecursive(5)); */
// factorialRecursive არის იდენტიფიკატორი, ფუნქციის სახელი და უმჯობესია ფუნქციის შესაბამისი სახელი ვუწოდო.
// (n) არის პარამეტრი, დროებითი ცვლადი, როდესაც ფუნქციას factorialRecursive გამოვიძახებ და მნიშვნელობაში ჩავუწერ მაგ: 5-ს n ტოლი იქნება 5-ის ანუ factorialRecursive(n) n = 5.
// n-ს შეიძლება სხვადასხვდა მნიშვნელობა მივანიჭო სხვვადასხვა ტიპის მონაცემი, მაგ: string, number, array.
// 5(n) * 4(5(n) - 1) (factorialRecursive(n - 1))
// რადგან       ⬆ აქ 5-1 მიწერია ფრჩხილებში, ჯერ ფრჩხილებში ჩაწერილი ფორმულა შესრულდება რადგან ფრჩხილები გამრავლებაზე უპირატესია.
// ამიტომ მივიღებ 5 * 4 -ს.
// function მუშაობის თანმიმდევრობა და ლოგიკა: ფუნქცია function არის თავისთვის და არავის არ უშლის ხელს, როდესაც მე დავწერე კონსოლ ლოგში: factorialRecursive(5) უკვე გამოვიძახე თავისთვის არსებული ფუნქცია, რადგან factorialRecursive არის ამ ფუნქციის სახელი. ფუნქცია გამოვიძახე ფუნქციას კი სახელის შემდეგ უწერია პარამეტრი: function factorialRecursive(n) აქ n გახდა 5-ი, რადგან n არის დროებითი ცვლადი რომელსაც მივანიჭე ამ წუთას მნიშვნელობა + n გამოვიყენე ფუნქციის შიგნით, მე ვერ დავწერდი function factorialRecursive(5) {}-ს რადგან პარამეტრის ფრჩხილებში შემიძლია მხოლოდ ცვლადის სახელის ჩაწერა, გინდაც ცვლადს მაგ: let 5 = 10 -ს ვერ შევქმნი, 5 ან 'ჰელო' სტრინგი არის მნიშვნელობა
// ფუნქციის შიგნით მიწერია: თუ n (ანუ 5)-ის მნიშვნელობა არის 0 და მონაცემის ტიპებითაც ერთნაირები არიან ან თუ n-ის მნიშვნელობა უდრის 1-ს და სევე არის number-ი როგორც 1 მაშინ ფუნქციიდან დააბრუნე 1 (return 1;), რა თქმა უნდა პირველ იტერაციაზე n-ის მნიშვნელბა არის 5-ი და არ შევა if პირობაში, if პირობის შემდეგ მიწერია return n * factorialRecursive(n - 1);, return რომ არ მეწეროს factorialRecursive მინშვნელობის პასუხს ფუნქცია არ დამიბრუნებდა და დაიტოვებდა შიგნით, n = 5-ს 5 * factorialRecursive(n - 1), 5 * 4-ზე = 20

// LIFO - Last In, First Out. LIFO არის აბრევიატურა, აბრევიატურა ნიშნავს რამდენიმე სიტყვისგან შემდგარი სახელწოდიების შემოკლება მათი საწყისი ასოების გაერთიანებით. არსებობს FIFO ნიშნავს First In First out რომელსაც მაღაზიებში ხმარობენ.
// 1. რეკურსია (Recursion) რეკურსია ნიშნავს როდესაც ფუნქცია საკუთარ თავს იძახებს ამ შემთხვევაში აქ: return n * factorialRecursive(n - 1);
// 2. ფაქტორიალი factorial არის მათემატიკური ოპერაცია. რიცხვის ფაქტორიალი ნიშნავს ყველა ნატურალური რიცხვის ანუ 5 4 3 2 1 და არა 0.99 ან 1.5 ნამრავლი რიცხვიდან ერთამდე იწერება ძახილის ნიშანი 5!(ხუთის ფაქტორიალი უდრის) = 5 * 4 * 3 * 2 * 1 = 120.
// 3. საბაზისო პირობა Base Case არის რეკურსიის მუხრუჭი, გამოსასვლელი წერტილი, როდესაც ფუნქციაში ვწერ რეკურსიას აუცილებლად უნდა დავამატო Base Case გამოსასვლელი წერტილი, თუ არ დავწერ კოდი უსასრულოდ გააგრძელებს მუშაობას და ბოლოს გაჭედავს.
// 4. Call Stack გამოძახების დასტა - არის კომპიუტერის მეხსიერება, სადაც ინახება ინფორმაცია იმ ფუნქციებზე, რომლებიც ჯერ არ შესრულებულა Call Stack ხდება აქ: return n * factorialRecursive(n - 1); გაყინული ანუ შენახული ინფორმაცია ფუნქციაზე არის return n * ➡ რომელიც არ შესრულდა და ელოდება factorialRecursive(n - 1)-ს.
// 5. არგუმენტი და პარამეტრი - პარამეტრი არის ცვლადი n function factorialRecursive(n) {} რომელიც ფუნქციის აღწერისას ჩავწერე, არგუმენტი არის 5, რეალური მნიშვნელობა რომელიც მივაწოდე ფუნქციას მისი გამოძახებისას.
// 6. Immutable უცვლელი - ეს არის მიდგომა, როდესაც ფუნქციში შექმნილ n-ს არ ვცვლი რეკურსიის დროს და ვქმნი ახალ n-ებს ყოველ ჯერზე.
// 7. Trigger გამომწვევი - Trigger არის console.log(getFactorialWithLoop(5)); რომელმაც ჩართო ფუნქცია, მექანიზმი, გამოიწვია. console.log(getFactorialWithLoop(5)); რომ არ დამეწერა არასდროს ჩაირთვებოდა ფუნქცია. ეს არის და ეს მეთელი ფუნქციის მუშაობა.

////////////////////////////////////////

/* function getFactorialWithLoop(n) {
    let result = 1; 
    for (let i = 1; i <= n; i++) {
        result = result * i;
        console.log(result);
    }
    return result;
    // result ასევე n ცვლადები იწყებენ არსებობას, სიცოცხლეს ფუნქციის ჩართვისას და ასრულებენ სიცოცხლეს ფუნქციის დასრულებისას.
    // result არის დროებითი ცვლადი, როდესაც for ლუპი შეწყვეტს მუშაობას და კომპიუტერი ჩამოვა return result; -ზე ფუნქციიდან დააბრუნებს არა ცვლად result-ს არამედ result-ის მნიშვნელობას ანუ 120-ს. მე თუ ფუნქციას გამოვიძახებ ასე: let n = getFactorialWithLoop(5); და შემდეგ დავლოგავ n-ს კომპიუტერი მიჩვენებს 120-ს, ანუ n = 120 და არა n = getFactorialWithLoop(120).
}
let n = getFactorialWithLoop(5); */ // n = 120

// "ბანკომატის ფაქტორიალი"

let on = true
while (on) {
    let factorialNumberInput = prompt('ჩაწერეთ სასურველი თანხის რიცხვი, 1-დან 10-მდე');
    if (factorialNumberInput === null || factorialNumberInput === '') {
        alert('ველი ცარიელია!');
        continue
    }
    let number = Number(factorialNumberInput);
    if (isNaN(number)) {
        alert('ჩაწერეთ მხოლოდ ციფრი!');
        continue
    } else if(number > 10) {
        alert('რიცხვი 10-ზე მეტია! შეიყვანეთ რიცხვი 1-დან 10-მდე')
        continue
    } else if (number % 2 === 0) {
        alert('რიცხვი ლუწია! ლუწ რიცხვს არ იღებს ბანკომატი');
        continue
    } else {
        let result = numberFactorial(number);
        alert(`შენი რიცხვის ფაქტორიალი უდრის: ${result} !`);
    }
    on = confirm('გსურთ გამოთვალოთ ახალი რიცხვის ფაქტორიალი? Ok - დიახ; CANCEL - არა.')
}
function numberFactorial(n) {
    if (n === 0 || n === 1) {
        return 1;
    }
    return n * numberFactorial(n - 1)
}
















































































































